"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TurboHTTPService = void 0;
/**
 * Copyright (C) 2022-2024 Permanent Data Solutions, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const axios_1 = require("axios");
const axiosClient_js_1 = require("../utils/axiosClient.js");
const errors_js_1 = require("../utils/errors.js");
class TurboHTTPService {
    constructor({ url, retryConfig, logger, }) {
        this.logger = logger;
        this.axios = (0, axiosClient_js_1.createAxiosInstance)({
            axiosConfig: {
                baseURL: url,
                maxRedirects: 0, // prevents backpressure issues when uploading larger streams via https
                onUploadProgress: (progressEvent) => {
                    this.logger.debug(`Uploading...`, {
                        percent: Math.floor((progressEvent.progress ?? 0) * 100),
                        loaded: `${progressEvent.loaded} bytes`,
                        total: `${progressEvent.total} bytes`,
                    });
                    if (progressEvent.progress === 1) {
                        this.logger.debug(`Upload complete!`);
                    }
                },
            },
            retryConfig,
            logger: this.logger,
        });
    }
    async get({ endpoint, signal, allowedStatuses = [200, 202], headers, }) {
        return this.tryRequest(() => this.axios.get(endpoint, { headers, signal }), allowedStatuses);
    }
    async post({ endpoint, signal, allowedStatuses = [200, 202], headers, data, }) {
        return this.tryRequest(() => this.axios.post(endpoint, data, { headers, signal }), allowedStatuses);
    }
    async tryRequest(request, allowedStatuses) {
        try {
            const { status, data, statusText } = await request();
            if (!allowedStatuses.includes(status)) {
                throw new errors_js_1.FailedRequestError(
                // Return error message from server if available
                typeof data === 'string' ? data : statusText, status);
            }
            return data;
        }
        catch (error) {
            if (error instanceof axios_1.CanceledError) {
                throw error;
            }
            if (error instanceof axios_1.AxiosError) {
                throw new errors_js_1.FailedRequestError(error.code ?? error.message, error.status);
            }
            throw error;
        }
    }
}
exports.TurboHTTPService = TurboHTTPService;
