import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
export declare const protobufPackage = "kyve.stakers.v1";
/** SlashType ... */
export declare enum SlashType {
    /** SLASH_TYPE_UNSPECIFIED - SLASH_TYPE_UNSPECIFIED ... */
    SLASH_TYPE_UNSPECIFIED = "SLASH_TYPE_UNSPECIFIED",
    /** SLASH_TYPE_TIMEOUT - SLASH_TYPE_TIMEOUT ... */
    SLASH_TYPE_TIMEOUT = "SLASH_TYPE_TIMEOUT",
    /** SLASH_TYPE_VOTE - SLASH_TYPE_VOTE ... */
    SLASH_TYPE_VOTE = "SLASH_TYPE_VOTE",
    /** SLASH_TYPE_UPLOAD - SLASH_TYPE_UPLOAD ... */
    SLASH_TYPE_UPLOAD = "SLASH_TYPE_UPLOAD",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function slashTypeFromJSON(object: any): SlashType;
export declare function slashTypeToJSON(object: SlashType): string;
export declare function slashTypeToNumber(object: SlashType): number;
/**
 * deprecated
 * Staker contains all metadata for a staker
 * Every address can only create one staker (itself)
 */
export interface Staker {
    /** address ... */
    address: string;
    /** commission ... */
    commission: string;
    /** moniker ... */
    moniker: string;
    /** website ... */
    website: string;
    /** identity is the 64 bit keybase.io identity string */
    identity: string;
    /** security_contact ... */
    security_contact: string;
    /** details are some additional notes the staker finds important */
    details: string;
    /** commission_rewards are the rewards through commission and storage cost */
    commission_rewards: Coin[];
}
/**
 * PoolAccount gets authorized by a validator to
 * vote in a given pool by favor of the validator.
 * The pool account basically acts like an operator
 * here so the validator private key can be stored
 * securely and not on a remote server where
 * the pool account will operate
 */
export interface PoolAccount {
    /**
     * pool_id defines the pool in which the address
     * is allowed to vote in.
     */
    pool_id: string;
    /** staker is the address validator */
    staker: string;
    /**
     * pool_address is the account stored on the protocol
     * node which votes for the staker in the given pool
     */
    pool_address: string;
    /**
     * When a node is inactive (does not vote at all)
     * A point is added, after a certain amount of points
     * is reached the node gets kicked out.
     */
    points: string;
    /** isLeaving indicates if a staker is leaving the given pool. */
    is_leaving: boolean;
    /** commission ... */
    commission: string;
    /** stake_fraction ... */
    stake_fraction: string;
}
/**
 * CommissionChangeEntry stores the information for an
 * upcoming commission change. A commission change is never
 * instant, so delegators have time to redelegate in case
 * they don't agree with the new commission.
 */
export interface CommissionChangeEntry {
    /**
     * index is needed for the queue-algorithm which
     * processes the commission changes
     */
    index: string;
    /** staker is the address of the affected staker */
    staker: string;
    /** pool_id ... */
    pool_id: string;
    /**
     * commission is the new commission which will
     * be applied after the waiting time is over.
     */
    commission: string;
    /**
     * creation_date is the UNIX-timestamp in seconds
     * when the entry was created.
     */
    creation_date: string;
}
/**
 * StakeFractionChangeEntry stores the information for an
 * upcoming stake fraction change. A stake fraction change is
 * only instant if it gets increased, if it gets decreased
 * the staker needs to wait for the stake fraction change time
 */
export interface StakeFractionChangeEntry {
    /**
     * index is needed for the queue-algorithm which
     * processes the commission changes
     */
    index: string;
    /** staker is the address of the affected staker */
    staker: string;
    /** pool_id ... */
    pool_id: string;
    /**
     * stake_fraction is the new stake fraction which will
     * be applied after the waiting time is over.
     */
    stake_fraction: string;
    /**
     * creation_date is the UNIX-timestamp in seconds
     * when the entry was created.
     */
    creation_date: string;
}
/**
 * LeavePoolEntry stores the information for an upcoming
 * pool leave. A staker can't leave a pool instantly.
 * Instead a the `LeaveTime` needs to be awaited.
 * If a staker start to leave a pool, it will be shown
 * in the UI to the delegators.
 */
export interface LeavePoolEntry {
    /**
     * index is needed for the queue-algorithm which
     * processes the commission changes
     */
    index: string;
    /** staker is the address of the affected staker */
    staker: string;
    /** pool_id indicates the pool the staker wants to leave */
    pool_id: string;
    /**
     * creation_date is the UNIX-timestamp in seconds
     * when the entry was created.
     */
    creation_date: string;
}
/** UnbondingState stores the state for the unbonding of stakes and delegations. */
export interface QueueState {
    /**
     * low_index is the tail of the queue. It is the
     * oldest entry in the queue. If this entry isn't
     * due, non of the other entries is.
     */
    low_index: string;
    /**
     * high_index is the head of the queue. New entries
     * are added to the top.
     */
    high_index: string;
}
export declare const Staker: MessageFns<Staker>;
export declare const PoolAccount: MessageFns<PoolAccount>;
export declare const CommissionChangeEntry: MessageFns<CommissionChangeEntry>;
export declare const StakeFractionChangeEntry: MessageFns<StakeFractionChangeEntry>;
export declare const LeavePoolEntry: MessageFns<LeavePoolEntry>;
export declare const QueueState: MessageFns<QueueState>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
