import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Proof } from "../crypto/proof";
import { Consensus } from "../version/types";
import { BlockIDFlag, ValidatorSet } from "./validator";
export declare const protobufPackage = "tendermint.types";
/** SignedMsgType is a type of signed message in the consensus. */
export declare enum SignedMsgType {
    SIGNED_MSG_TYPE_UNKNOWN = "SIGNED_MSG_TYPE_UNKNOWN",
    /** SIGNED_MSG_TYPE_PREVOTE - Votes */
    SIGNED_MSG_TYPE_PREVOTE = "SIGNED_MSG_TYPE_PREVOTE",
    SIGNED_MSG_TYPE_PRECOMMIT = "SIGNED_MSG_TYPE_PRECOMMIT",
    /** SIGNED_MSG_TYPE_PROPOSAL - Proposals */
    SIGNED_MSG_TYPE_PROPOSAL = "SIGNED_MSG_TYPE_PROPOSAL",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function signedMsgTypeFromJSON(object: any): SignedMsgType;
export declare function signedMsgTypeToJSON(object: SignedMsgType): string;
export declare function signedMsgTypeToNumber(object: SignedMsgType): number;
/** PartsetHeader */
export interface PartSetHeader {
    total: number;
    hash: Uint8Array;
}
export interface Part {
    index: number;
    bytes: Uint8Array;
    proof?: Proof | undefined;
}
/** BlockID */
export interface BlockID {
    hash: Uint8Array;
    part_set_header?: PartSetHeader | undefined;
}
/** Header defines the structure of a block header. */
export interface Header {
    /** basic block info */
    version?: Consensus | undefined;
    chain_id: string;
    height: string;
    time?: Date | undefined;
    /** prev block info */
    last_block_id?: BlockID | undefined;
    /** hashes of block data */
    last_commit_hash: Uint8Array;
    /** transactions */
    data_hash: Uint8Array;
    /** hashes from the app output from the prev block */
    validators_hash: Uint8Array;
    /** validators for the next block */
    next_validators_hash: Uint8Array;
    /** consensus params for current block */
    consensus_hash: Uint8Array;
    /** state after txs from the previous block */
    app_hash: Uint8Array;
    /** root hash of all results from the txs from the previous block */
    last_results_hash: Uint8Array;
    /** consensus info */
    evidence_hash: Uint8Array;
    /** original proposer of the block */
    proposer_address: Uint8Array;
}
/** Data contains the set of transactions included in the block */
export interface Data {
    /**
     * Txs that will be applied by state @ block.Height+1.
     * NOTE: not all txs here are valid.  We're just agreeing on the order first.
     * This means that block.AppHash does not include these txs.
     */
    txs: Uint8Array[];
}
/**
 * Vote represents a prevote or precommit vote from validators for
 * consensus.
 */
export interface Vote {
    type: SignedMsgType;
    height: string;
    round: number;
    /** zero if vote is nil. */
    block_id?: BlockID | undefined;
    timestamp?: Date | undefined;
    validator_address: Uint8Array;
    validator_index: number;
    /**
     * Vote signature by the validator if they participated in consensus for the
     * associated block.
     */
    signature: Uint8Array;
    /**
     * Vote extension provided by the application. Only valid for precommit
     * messages.
     */
    extension: Uint8Array;
    /**
     * Vote extension signature by the validator if they participated in
     * consensus for the associated block.
     * Only valid for precommit messages.
     */
    extension_signature: Uint8Array;
}
/** Commit contains the evidence that a block was committed by a set of validators. */
export interface Commit {
    height: string;
    round: number;
    block_id?: BlockID | undefined;
    signatures: CommitSig[];
}
/** CommitSig is a part of the Vote included in a Commit. */
export interface CommitSig {
    block_id_flag: BlockIDFlag;
    validator_address: Uint8Array;
    timestamp?: Date | undefined;
    signature: Uint8Array;
}
export interface ExtendedCommit {
    height: string;
    round: number;
    block_id?: BlockID | undefined;
    extended_signatures: ExtendedCommitSig[];
}
/**
 * ExtendedCommitSig retains all the same fields as CommitSig but adds vote
 * extension-related fields. We use two signatures to ensure backwards compatibility.
 * That is the digest of the original signature is still the same in prior versions
 */
export interface ExtendedCommitSig {
    block_id_flag: BlockIDFlag;
    validator_address: Uint8Array;
    timestamp?: Date | undefined;
    signature: Uint8Array;
    /** Vote extension data */
    extension: Uint8Array;
    /** Vote extension signature */
    extension_signature: Uint8Array;
}
export interface Proposal {
    type: SignedMsgType;
    height: string;
    round: number;
    pol_round: number;
    block_id?: BlockID | undefined;
    timestamp?: Date | undefined;
    signature: Uint8Array;
}
export interface SignedHeader {
    header?: Header | undefined;
    commit?: Commit | undefined;
}
export interface LightBlock {
    signed_header?: SignedHeader | undefined;
    validator_set?: ValidatorSet | undefined;
}
export interface BlockMeta {
    block_id?: BlockID | undefined;
    block_size: string;
    header?: Header | undefined;
    num_txs: string;
}
/** TxProof represents a Merkle proof of the presence of a transaction in the Merkle tree. */
export interface TxProof {
    root_hash: Uint8Array;
    data: Uint8Array;
    proof?: Proof | undefined;
}
export declare const PartSetHeader: MessageFns<PartSetHeader>;
export declare const Part: MessageFns<Part>;
export declare const BlockID: MessageFns<BlockID>;
export declare const Header: MessageFns<Header>;
export declare const Data: MessageFns<Data>;
export declare const Vote: MessageFns<Vote>;
export declare const Commit: MessageFns<Commit>;
export declare const CommitSig: MessageFns<CommitSig>;
export declare const ExtendedCommit: MessageFns<ExtendedCommit>;
export declare const ExtendedCommitSig: MessageFns<ExtendedCommitSig>;
export declare const Proposal: MessageFns<Proposal>;
export declare const SignedHeader: MessageFns<SignedHeader>;
export declare const LightBlock: MessageFns<LightBlock>;
export declare const BlockMeta: MessageFns<BlockMeta>;
export declare const TxProof: MessageFns<TxProof>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
