import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
export declare const protobufPackage = "kyve.query.v1beta1";
/** FundingStatus ... */
export declare enum FundingStatus {
    /** FUNDING_STATUS_UNSPECIFIED - FundingStatusUnspecified ... */
    FUNDING_STATUS_UNSPECIFIED = "FUNDING_STATUS_UNSPECIFIED",
    /** FUNDING_STATUS_ACTIVE - FundingStatusActive status is set when the funding is active. */
    FUNDING_STATUS_ACTIVE = "FUNDING_STATUS_ACTIVE",
    /** FUNDING_STATUS_INACTIVE - FundingStatusInactive status is set when the funding has been used up or refunded. */
    FUNDING_STATUS_INACTIVE = "FUNDING_STATUS_INACTIVE",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function fundingStatusFromJSON(object: any): FundingStatus;
export declare function fundingStatusToJSON(object: FundingStatus): string;
export declare function fundingStatusToNumber(object: FundingStatus): number;
/** Funder ... */
export interface Funder {
    /** address ... */
    address: string;
    /** moniker ... */
    moniker: string;
    /** identity is the 64 bit keybase.io identity string */
    identity: string;
    /** website ... */
    website: string;
    /** contact ... */
    contact: string;
    /** description ... */
    description: string;
    /** statistics about all the fundings of the funder. */
    stats?: FundingStats | undefined;
}
/** FundingStats ... */
export interface FundingStats {
    /** total_used_funds are the total funds that have been distributed by the funder. */
    total_used_funds: Coin[];
    /**
     * total_allocated_funds are the total funds that have been allocated by the funder.
     * They can either get distributed or refunded.
     */
    total_allocated_funds: Coin[];
    /** total_amount_per_bundle is the total amount per bundle of all fundings of the funder. */
    total_amount_per_bundle: Coin[];
    /** pools_funded are the ids of the pools that have been funded by the funder. */
    pools_funded: string[];
    /**
     * score is the result of all coins of the funder currently allocated times the coin weight
     * specified in the params
     */
    score: string;
}
/** Funding ... */
export interface Funding {
    /** funder_id is the id of the funder */
    funder_address: string;
    /** pool_id is the id of the pool this funding is for */
    pool_id: string;
    /** amounts is a list of coins the funder wants to fund the pool with */
    amounts: Coin[];
    /**
     * amounts_per_bundle defines the amount of each coin that are distributed
     * per finalized bundle
     */
    amounts_per_bundle: Coin[];
    /** total_funded is the total amount of coins that the funder has funded */
    total_funded: Coin[];
    /**
     * score is the result of all coins allocated to this pool times the coin weight specified
     * by the params
     */
    score: string;
}
/** QueryFundersRequest is the request type for the Query/Funders RPC method. */
export interface QueryFundersRequest {
    /** pagination defines an optional pagination for the request. */
    pagination?: PageRequest | undefined;
    /** search ... */
    search: string;
}
/** QueryFundersResponse is the response type for the Query/Funders RPC method. */
export interface QueryFundersResponse {
    /** pagination defines the pagination in the response. */
    pagination?: PageResponse | undefined;
    /** funders ... */
    funders: Funder[];
}
/** QueryFunderRequest is the request type for the Query/Funder RPC method. */
export interface QueryFunderRequest {
    /** address ... */
    address: string;
    /** status ... */
    status: FundingStatus;
}
/** QueryFunderResponse is the response type for the Query/Funder RPC method. */
export interface QueryFunderResponse {
    /** funder ... */
    funder?: Funder | undefined;
    /** fundings ... */
    fundings: Funding[];
}
/** QueryFundingsByFunderRequest is the request type for the Query/FundingsByFunder RPC method. */
export interface QueryFundingsByFunderRequest {
    /** pagination defines an optional pagination for the request. */
    pagination?: PageRequest | undefined;
    /** address ... */
    address: string;
    /** status ... */
    status: FundingStatus;
}
/** QueryFundingsByFunderResponse is the response type for the Query/FundingsByFunder RPC method. */
export interface QueryFundingsByFunderResponse {
    /** pagination defines the pagination in the response. */
    pagination?: PageResponse | undefined;
    /** fundings ... */
    fundings: Funding[];
}
/** QueryFundingsByPoolRequest is the request type for the Query/FundingsByPool RPC method. */
export interface QueryFundingsByPoolRequest {
    /** pagination defines an optional pagination for the request. */
    pagination?: PageRequest | undefined;
    /** pool_id ... */
    pool_id: string;
    /** status ... */
    status: FundingStatus;
}
/** QueryFundingsByPoolResponse is the response type for the Query/FundingsByPool RPC method. */
export interface QueryFundingsByPoolResponse {
    /** pagination defines the pagination in the response. */
    pagination?: PageResponse | undefined;
    /** fundings ... */
    fundings: Funding[];
}
export declare const Funder: MessageFns<Funder>;
export declare const FundingStats: MessageFns<FundingStats>;
export declare const Funding: MessageFns<Funding>;
export declare const QueryFundersRequest: MessageFns<QueryFundersRequest>;
export declare const QueryFundersResponse: MessageFns<QueryFundersResponse>;
export declare const QueryFunderRequest: MessageFns<QueryFunderRequest>;
export declare const QueryFunderResponse: MessageFns<QueryFunderResponse>;
export declare const QueryFundingsByFunderRequest: MessageFns<QueryFundingsByFunderRequest>;
export declare const QueryFundingsByFunderResponse: MessageFns<QueryFundingsByFunderResponse>;
export declare const QueryFundingsByPoolRequest: MessageFns<QueryFundingsByPoolRequest>;
export declare const QueryFundingsByPoolResponse: MessageFns<QueryFundingsByPoolResponse>;
/** QueryFunders ... */
export interface QueryFunders {
    /** Funders queries all funders. */
    Funders(request: QueryFundersRequest): Promise<QueryFundersResponse>;
    /** Funder queries a funder by address. */
    Funder(request: QueryFunderRequest): Promise<QueryFunderResponse>;
    /** FundingsByFunder queries all fundings of a funder by address. */
    FundingsByFunder(request: QueryFundingsByFunderRequest): Promise<QueryFundingsByFunderResponse>;
    /** FundingsByPool queries all fundings of a pool by id. */
    FundingsByPool(request: QueryFundingsByPoolRequest): Promise<QueryFundingsByPoolResponse>;
}
export declare const QueryFundersServiceName = "kyve.query.v1beta1.QueryFunders";
export declare class QueryFundersClientImpl implements QueryFunders {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    Funders(request: QueryFundersRequest): Promise<QueryFundersResponse>;
    Funder(request: QueryFunderRequest): Promise<QueryFunderResponse>;
    FundingsByFunder(request: QueryFundingsByFunderRequest): Promise<QueryFundingsByFunderResponse>;
    FundingsByPool(request: QueryFundingsByPoolRequest): Promise<QueryFundingsByPoolResponse>;
}
interface Rpc {
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
