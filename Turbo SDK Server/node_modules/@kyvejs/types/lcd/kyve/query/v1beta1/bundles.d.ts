import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
export declare const protobufPackage = "kyve.query.v1beta1";
/** FinalizedBundle represents the latest version of a valid bundle of a pool */
export interface FinalizedBundle {
    /** pool_id in which the bundle was created */
    pool_id: string;
    /** id is is integrated with each valid bundle produced. */
    id: string;
    /** storage_id is the id with which the data can be retrieved from the configured data provider */
    storage_id: string;
    /** uploader is the address of the staker who submitted this bundle */
    uploader: string;
    /** from_index is the index from where the bundle starts (inclusive) */
    from_index: string;
    /** to_index is the index to which the bundle goes (exclusive) */
    to_index: string;
    /** from_key is the key of the first data item in the bundle proposal */
    from_key: string;
    /** to_key the key of the last data item in the bundle */
    to_key: string;
    /** bundle_summary is a summary of the bundle. */
    bundle_summary: string;
    /** data_hash is a sha256 hash of the uploaded data. */
    data_hash: string;
    /** finalized_at contains details of the block that finalized this bundle. */
    finalized_at?: FinalizedAt | undefined;
    /** storage_provider_id the id of the storage provider where the bundle is stored */
    storage_provider_id: string;
    /** compression_id the id of the compression type with which the data was compressed */
    compression_id: string;
    /**
     * stake_security defines the amount of stake which was present in the pool during the finalization of the bundle.
     * This field was added in schema version 2. Bundles finalized before that return `null`.
     */
    stake_security?: StakeSecurity | undefined;
}
/** FinalizedAt stores information about finalization block and time. */
export interface FinalizedAt {
    /** height is the block height in which the bundle got finalized. */
    height: string;
    /** timestamp is the UNIX timestamp of the block in which the bundle got finalized. */
    timestamp: string;
}
/** StakeSecurity represents the relative security of a finalized bundle */
export interface StakeSecurity {
    /** valid_vote_power gives the amount of $KYVE stake that voted `valid`. */
    valid_vote_power: string;
    /**
     * total_vote_power gives the amount of total $KYVE stake that was present in the pool
     * during finalization.
     */
    total_vote_power: string;
}
/** QueryFinalizedBundlesRequest is the request type for the Query/Staker RPC method. */
export interface QueryFinalizedBundlesRequest {
    /** pagination defines an optional pagination for the request. */
    pagination?: PageRequest | undefined;
    /** pool_id ... */
    pool_id: string;
    /**
     * index is an optional parameter which tells the server to only show
     * the bundle with the given index. This can not be combined with pagination.
     */
    index: string;
}
/** QueryStakersByPoolResponse is the response type for the Query/Staker RPC method. */
export interface QueryFinalizedBundlesResponse {
    /** finalized_bundles ... */
    finalized_bundles: FinalizedBundle[];
    /** pagination defines the pagination in the response. */
    pagination?: PageResponse | undefined;
}
/** QueryFinalizedBundleRequest is the request type for the Query/Staker RPC method. */
export interface QueryFinalizedBundleRequest {
    /** pool_id ... */
    pool_id: string;
    /** id ... */
    id: string;
}
/** QueryFinalizedBundleResponse is the response type for the Query/Staker RPC method. */
export interface QueryFinalizedBundleResponse {
    /** pool_id in which the bundle was created */
    pool_id: string;
    /** id is is integrated with each valid bundle produced. */
    id: string;
    /** storage_id is the id with which the data can be retrieved from the configured data provider */
    storage_id: string;
    /** uploader is the address of the staker who submitted this bundle */
    uploader: string;
    /** from_index is the index from where the bundle starts (inclusive) */
    from_index: string;
    /** to_index is the index to which the bundle goes (exclusive) */
    to_index: string;
    /** from_key is the key of the first data item in the bundle proposal */
    from_key: string;
    /** to_key the key of the last data item in the bundle */
    to_key: string;
    /** bundle_summary is a summary of the bundle. */
    bundle_summary: string;
    /** data_hash is a sha256 hash of the uploaded data. */
    data_hash: string;
    /** finalized_at contains details of the block that finalized this bundle. */
    finalized_at?: FinalizedAt | undefined;
    /** storage_provider_id the id of the storage provider where the bundle is stored */
    storage_provider_id: string;
    /** compression_id the id of the compression type with which the data was compressed */
    compression_id: string;
    /**
     * stake_security defines the amount of stake which was present in the pool during the finalization of the bundle.
     * This field was added in schema version 2. Bundles finalized before that return `null`.
     */
    stake_security?: StakeSecurity | undefined;
}
/** QueryCurrentVoteStatusRequest is the request type for the Query/Staker RPC method. */
export interface QueryCurrentVoteStatusRequest {
    /** pool_id ... */
    pool_id: string;
}
/** QueryCurrentVoteStatusResponse is the response type for the Query/Staker RPC method. */
export interface QueryCurrentVoteStatusResponse {
    /** valid ... */
    valid: string;
    /** invalid ... */
    invalid: string;
    /** abstain ... */
    abstain: string;
    /** total ... */
    total: string;
}
/** QueryCanProposeRequest is the request type for the Query/CanPropose RPC method. */
export interface QueryCanValidateRequest {
    /** pool_id defines the unique ID of the pool. */
    pool_id: string;
    /** pool_address ... */
    pool_address: string;
}
/** QueryCanProposeResponse is the response type for the Query/CanPropose RPC method. */
export interface QueryCanValidateResponse {
    /** possible ... */
    possible: boolean;
    /** reason ... */
    reason: string;
}
/** QueryCanProposeRequest is the request type for the Query/CanPropose RPC method. */
export interface QueryCanProposeRequest {
    /** pool_id defines the unique ID of the pool. */
    pool_id: string;
    /** staker ... */
    staker: string;
    /** proposer ... */
    proposer: string;
    /** from_index ... */
    from_index: string;
}
/** QueryCanProposeResponse is the response type for the Query/CanPropose RPC method. */
export interface QueryCanProposeResponse {
    /** possible ... */
    possible: boolean;
    /** reason ... */
    reason: string;
}
/** QueryCanVoteRequest is the request type for the Query/CanVote RPC method. */
export interface QueryCanVoteRequest {
    /** pool_id defines the unique ID of the pool. */
    pool_id: string;
    /** staker ... */
    staker: string;
    /** voter ... */
    voter: string;
    /** storage_id ... */
    storage_id: string;
}
/** QueryCanVoteResponse is the response type for the Query/CanVote RPC method. */
export interface QueryCanVoteResponse {
    /** possible ... */
    possible: boolean;
    /** reason ... */
    reason: string;
}
export declare const FinalizedBundle: MessageFns<FinalizedBundle>;
export declare const FinalizedAt: MessageFns<FinalizedAt>;
export declare const StakeSecurity: MessageFns<StakeSecurity>;
export declare const QueryFinalizedBundlesRequest: MessageFns<QueryFinalizedBundlesRequest>;
export declare const QueryFinalizedBundlesResponse: MessageFns<QueryFinalizedBundlesResponse>;
export declare const QueryFinalizedBundleRequest: MessageFns<QueryFinalizedBundleRequest>;
export declare const QueryFinalizedBundleResponse: MessageFns<QueryFinalizedBundleResponse>;
export declare const QueryCurrentVoteStatusRequest: MessageFns<QueryCurrentVoteStatusRequest>;
export declare const QueryCurrentVoteStatusResponse: MessageFns<QueryCurrentVoteStatusResponse>;
export declare const QueryCanValidateRequest: MessageFns<QueryCanValidateRequest>;
export declare const QueryCanValidateResponse: MessageFns<QueryCanValidateResponse>;
export declare const QueryCanProposeRequest: MessageFns<QueryCanProposeRequest>;
export declare const QueryCanProposeResponse: MessageFns<QueryCanProposeResponse>;
export declare const QueryCanVoteRequest: MessageFns<QueryCanVoteRequest>;
export declare const QueryCanVoteResponse: MessageFns<QueryCanVoteResponse>;
/** QueryDelegation contains all rpc requests related to direct delegation data */
export interface QueryBundles {
    /** FinalizedBundles ... */
    FinalizedBundlesQuery(request: QueryFinalizedBundlesRequest): Promise<QueryFinalizedBundlesResponse>;
    /** FinalizedBundle ... */
    FinalizedBundleQuery(request: QueryFinalizedBundleRequest): Promise<QueryFinalizedBundleResponse>;
    /** CurrentVoteStatus ... */
    CurrentVoteStatus(request: QueryCurrentVoteStatusRequest): Promise<QueryCurrentVoteStatusResponse>;
    /** CanValidate ... */
    CanValidate(request: QueryCanValidateRequest): Promise<QueryCanValidateResponse>;
    /** CanPropose ... */
    CanPropose(request: QueryCanProposeRequest): Promise<QueryCanProposeResponse>;
    /** CanVote checks if voter on pool can still vote for the given bundle */
    CanVote(request: QueryCanVoteRequest): Promise<QueryCanVoteResponse>;
}
export declare const QueryBundlesServiceName = "kyve.query.v1beta1.QueryBundles";
export declare class QueryBundlesClientImpl implements QueryBundles {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    FinalizedBundlesQuery(request: QueryFinalizedBundlesRequest): Promise<QueryFinalizedBundlesResponse>;
    FinalizedBundleQuery(request: QueryFinalizedBundleRequest): Promise<QueryFinalizedBundleResponse>;
    CurrentVoteStatus(request: QueryCurrentVoteStatusRequest): Promise<QueryCurrentVoteStatusResponse>;
    CanValidate(request: QueryCanValidateRequest): Promise<QueryCanValidateResponse>;
    CanPropose(request: QueryCanProposeRequest): Promise<QueryCanProposeResponse>;
    CanVote(request: QueryCanVoteRequest): Promise<QueryCanVoteResponse>;
}
interface Rpc {
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
