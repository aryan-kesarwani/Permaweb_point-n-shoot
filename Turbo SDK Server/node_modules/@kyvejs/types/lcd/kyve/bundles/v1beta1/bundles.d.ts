import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export declare const protobufPackage = "kyve.bundles.v1beta1";
/**
 * BundleStatus represents the status of an evaluated bundle
 * proposal.
 */
export declare enum BundleStatus {
    /** BUNDLE_STATUS_UNSPECIFIED - BUNDLE_STATUS_UNSPECIFIED ... */
    BUNDLE_STATUS_UNSPECIFIED = "BUNDLE_STATUS_UNSPECIFIED",
    /** BUNDLE_STATUS_VALID - BUNDLE_STATUS_VALID ... */
    BUNDLE_STATUS_VALID = "BUNDLE_STATUS_VALID",
    /** BUNDLE_STATUS_INVALID - BUNDLE_STATUS_INVALID ... */
    BUNDLE_STATUS_INVALID = "BUNDLE_STATUS_INVALID",
    /** BUNDLE_STATUS_NO_FUNDS - BUNDLE_STATUS_NO_FUNDS ... */
    BUNDLE_STATUS_NO_FUNDS = "BUNDLE_STATUS_NO_FUNDS",
    /** BUNDLE_STATUS_NO_QUORUM - BUNDLE_STATUS_NO_QUORUM ... */
    BUNDLE_STATUS_NO_QUORUM = "BUNDLE_STATUS_NO_QUORUM",
    /** BUNDLE_STATUS_DISABLED - BUNDLE_STATUS_DISABLED  ... */
    BUNDLE_STATUS_DISABLED = "BUNDLE_STATUS_DISABLED",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function bundleStatusFromJSON(object: any): BundleStatus;
export declare function bundleStatusToJSON(object: BundleStatus): string;
export declare function bundleStatusToNumber(object: BundleStatus): number;
/**
 * BundleProposal represents the current bundle proposal
 * of a storage pool
 */
export interface BundleProposal {
    /** pool_id is the id of the pool for which this proposal is for */
    pool_id: string;
    /** storage_id is the id with which the data can be retrieved from */
    storage_id: string;
    /** uploader is the address of the staker who submitted the current proposal */
    uploader: string;
    /** next_uploader is the address of the staker who should upload the next proposal */
    next_uploader: string;
    /** data_size the size of the data in bytes */
    data_size: string;
    /** bundle_size the size of the bundle (amount of data items) */
    bundle_size: string;
    /** to_key the key of the last data item in the bundle proposal */
    to_key: string;
    /** bundle_summary a string summary of the current proposal */
    bundle_summary: string;
    /** data_hash a sha256 hash of the raw compressed data */
    data_hash: string;
    /** updated_at the last time this proposal was edited */
    updated_at: string;
    /** voters_valid list of all stakers who voted in favor for current proposal */
    voters_valid: string[];
    /** voters_invalid list of all stakers who voted against for current proposal */
    voters_invalid: string[];
    /** voters_abstain list of all stakers who voted abstain for current proposal */
    voters_abstain: string[];
    /** from_key the key of the first data item in the bundle proposal */
    from_key: string;
    /** storage_provider_id the id of the storage provider where the bundle is stored */
    storage_provider_id: number;
    /** compression_id the id of the compression type with which the data was compressed */
    compression_id: number;
}
/**
 * FinalizedBundle represents a bundle proposal where the majority
 * agreed on its validity
 */
export interface FinalizedBundle {
    /** pool_id is the id of the pool for which this proposal is for */
    pool_id: string;
    /** id is a unique identifier for each finalized bundle in a pool */
    id: string;
    /** storage_id is the id with which the data can be retrieved from */
    storage_id: string;
    /** uploader is the address of the staker who submitted this bundle */
    uploader: string;
    /** from_index is the index from where the bundle starts (inclusive) */
    from_index: string;
    /** to_index is the index to which the bundle goes (exclusive) */
    to_index: string;
    /** to_key the key of the last data item in the bundle proposal */
    to_key: string;
    /** bundle_summary a string summary of the current proposal */
    bundle_summary: string;
    /** data_hash a sha256 hash of the raw compressed data */
    data_hash: string;
    /** finalized_at contains details of the block that finalized this bundle. */
    finalized_at?: FinalizedAt | undefined;
    /** from_key the key of the first data item in the bundle proposal */
    from_key: string;
    /** storage_provider_id the id of the storage provider where the bundle is stored */
    storage_provider_id: number;
    /** compression_id the id of the compression type with which the data was compressed */
    compression_id: number;
    /** stake_security */
    stake_security?: StakeSecurity | undefined;
}
/** FinalizedAt ... */
export interface FinalizedAt {
    /** height ... */
    height: string;
    /** timestamp ... */
    timestamp: string;
}
/** StakeSecurity stores information about total stake and valid votes with which the bundle got finalized. */
export interface StakeSecurity {
    /** valid_vote_power is the total amount of stake of all pool stakers which voted valid for the given bundle. */
    valid_vote_power: string;
    /** total_vote_power is the total amount of stake that was present during the finalization of the bundle */
    total_vote_power: string;
}
/** BundleVersionEntry ... */
export interface BundleVersionEntry {
    /** height ... */
    height: string;
    /** version ... */
    version: number;
}
/** BundleVersionMap ... */
export interface BundleVersionMap {
    /** versions ... */
    versions: BundleVersionEntry[];
}
/** RoundRobinSingleValidatorProgress ... */
export interface RoundRobinSingleValidatorProgress {
    /** address ... */
    address: string;
    /** progress ... */
    progress: string;
}
/** RoundRobinProgress ... */
export interface RoundRobinProgress {
    /** pool_id ... */
    pool_id: string;
    /** progress_list ... */
    progress_list: RoundRobinSingleValidatorProgress[];
}
export declare const BundleProposal: MessageFns<BundleProposal>;
export declare const FinalizedBundle: MessageFns<FinalizedBundle>;
export declare const FinalizedAt: MessageFns<FinalizedAt>;
export declare const StakeSecurity: MessageFns<StakeSecurity>;
export declare const BundleVersionEntry: MessageFns<BundleVersionEntry>;
export declare const BundleVersionMap: MessageFns<BundleVersionMap>;
export declare const RoundRobinSingleValidatorProgress: MessageFns<RoundRobinSingleValidatorProgress>;
export declare const RoundRobinProgress: MessageFns<RoundRobinProgress>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
