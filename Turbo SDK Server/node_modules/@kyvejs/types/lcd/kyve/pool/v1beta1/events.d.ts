import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Params } from "./params";
export declare const protobufPackage = "kyve.pool.v1beta1";
/**
 * EventUpdateParams is an event emitted when the module parameters are updated.
 * emitted_by: MsgUpdateParams
 */
export interface EventUpdateParams {
    /** old_params is the module's old parameters. */
    old_params?: Params | undefined;
    /** new_params is the module's new parameters. */
    new_params?: Params | undefined;
    /** payload is the parameter updates that were performed. */
    payload: string;
}
/**
 * EventCreatePool ...
 * emitted_by: EndBlock(gov)
 */
export interface EventCreatePool {
    /** id is the unique ID of the pool. */
    id: string;
    /** name is the human readable name of the pool */
    name: string;
    /** runtime is the runtime name of the pool */
    runtime: string;
    /** logo is the logo url of the pool */
    logo: string;
    /**
     * config is either a json stringified config or an
     * external link pointing to the config
     */
    config: string;
    /**
     * start_key is the first key the pool should start
     * indexing
     */
    start_key: string;
    /**
     * upload_interval is the interval the pool should validate
     * bundles with
     */
    upload_interval: string;
    /**
     * inflation_share_weight is the fixed cost which gets paid out
     * to every successful uploader
     */
    inflation_share_weight: string;
    /**
     * min_delegation is the minimum amount of $KYVE the pool has
     * to have in order to produce bundles
     */
    min_delegation: string;
    /**
     * max_bundle_size is the max size a data bundle can have
     * (amount of data items)
     */
    max_bundle_size: string;
    /** version is the current version of the protocol nodes */
    version: string;
    /** binaries points to the current binaries of the protocol node */
    binaries: string;
    /**
     * storage_provider_id is the unique id of the storage provider
     * the pool is archiving the data on
     */
    storage_provider_id: number;
    /**
     * compression_id is the unique id of the compression type the bundles
     * get compressed with
     */
    compression_id: number;
    /**
     * end_key is the last key before the pool should stop indexing, it is
     * inclusive
     */
    end_key: string;
}
/**
 * EventPoolEnabled ...
 * emitted_by: EndBlock(gov)
 */
export interface EventPoolEnabled {
    /** id is the unique ID of the affected pool. */
    id: string;
}
/**
 * EventPoolDisabled ...
 * emitted_by: EndBlock(gov)
 */
export interface EventPoolDisabled {
    /** id is the unique ID of the affected pool. */
    id: string;
}
/**
 * EventRuntimeUpgradeScheduled ...
 * emitted_by: EndBlock(gov)
 */
export interface EventRuntimeUpgradeScheduled {
    /** runtime is the name of the runtime that will be upgraded. */
    runtime: string;
    /** version is the new version that the runtime will be upgraded to. */
    version: string;
    /** scheduled_at is the time in UNIX seconds when the upgrade will occur. */
    scheduled_at: string;
    /**
     * duration is the amount of seconds the pool will be paused after the
     * scheduled time is reached. This will give node operators time to upgrade
     * their node.
     */
    duration: string;
    /** binaries contain download links for prebuilt binaries (in JSON format). */
    binaries: string;
    /** affected_pools contains all IDs of pools that will be affected by this runtime upgrade. */
    affected_pools: string[];
}
/**
 * EventRuntimeUpgradeCancelled ...
 * emitted_by: EndBlock(gov)
 */
export interface EventRuntimeUpgradeCancelled {
    /** runtime is the name of the runtime that will be upgraded. */
    runtime: string;
    /**
     * affected_pools contains all IDs of pools that are affected by the
     * cancellation of this runtime upgrade.
     */
    affected_pools: string[];
}
/**
 * EventPoolUpdated ...
 * emitted_by: EndBlock(gov)
 */
export interface EventPoolUpdated {
    /** id is the unique ID of the pool. */
    id: string;
    /** raw update string */
    raw_update_string: string;
    /** name is the human readable name of the pool */
    name: string;
    /** runtime is the runtime name of the pool */
    runtime: string;
    /** logo is the logo url of the pool */
    logo: string;
    /**
     * config is either a json stringified config or an
     * external link pointing to the config
     */
    config: string;
    /**
     * upload_interval is the interval the pool should validate
     * bundles with
     */
    upload_interval: string;
    /**
     * inflation_share_weight is the fixed cost which gets paid out
     * to every successful uploader
     */
    inflation_share_weight: string;
    /**
     * min_delegation is the minimum amount of $KYVE the pool has
     * to have in order to produce bundles
     */
    min_delegation: string;
    /**
     * max_bundle_size is the max size a data bundle can have
     * (amount of data items)
     */
    max_bundle_size: string;
    /**
     * storage_provider_id is the unique id of the storage provider
     * the pool is archiving the data on
     */
    storage_provider_id: number;
    /**
     * compression_id is the unique id of the compression type the bundles
     * get compressed with
     */
    compression_id: number;
}
/**
 * EventDefundPool is an event emitted when a pool is defunded.
 * emitted_by: MsgSubmitBundleProposal
 */
export interface EventPoolFundsSlashed {
    /** pool_id is the unique ID of the pool. */
    pool_id: string;
    /** address is the account address of the pool funder. */
    address: string;
    /** amount is the amount in ukyve the validator has lost due to the slash */
    amount: string;
}
export declare const EventUpdateParams: MessageFns<EventUpdateParams>;
export declare const EventCreatePool: MessageFns<EventCreatePool>;
export declare const EventPoolEnabled: MessageFns<EventPoolEnabled>;
export declare const EventPoolDisabled: MessageFns<EventPoolDisabled>;
export declare const EventRuntimeUpgradeScheduled: MessageFns<EventRuntimeUpgradeScheduled>;
export declare const EventRuntimeUpgradeCancelled: MessageFns<EventRuntimeUpgradeCancelled>;
export declare const EventPoolUpdated: MessageFns<EventPoolUpdated>;
export declare const EventPoolFundsSlashed: MessageFns<EventPoolFundsSlashed>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
