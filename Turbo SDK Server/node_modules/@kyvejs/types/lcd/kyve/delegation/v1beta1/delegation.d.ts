import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin, DecCoin } from "../../../cosmos/base/v1beta1/coin";
export declare const protobufPackage = "kyve.delegation.v1beta1";
/**
 * Delegator stores the information that one address has delegated to another address
 * It stores important information for the F1-Fee distribution algorithm
 */
export interface Delegator {
    /** staker corresponds to a KYVE-staker on the protocol-side */
    staker: string;
    /**
     * delegator the user who delegate to the staker.
     * If staker and delegator are the same we call it: self-delegation
     */
    delegator: string;
    /** k_index is an internal index for the f1-distribution algorithm */
    k_index: string;
    /**
     * initial_amount of stake the user had when it delegated.
     * slashes can cause that the actual stake is lower.
     */
    initial_amount: string;
}
/**
 * DelegationEntry represents an entry according to the F1-Fee-Distribution algorithm.
 * Take a look at x/delegation/keeper/logic_f1distribution.go for more details
 */
export interface DelegationEntry {
    /** staker on protocol level */
    staker: string;
    /** k_index is the of the period this entry ends */
    k_index: string;
    /** value is the quotient of collected rewards and total stake according to F1-distribution */
    value: DecCoin[];
}
/** DelegationPoolData stores general delegation information for every staker */
export interface DelegationData {
    /** Every staker has one DelegationData */
    staker: string;
    /** current_rewards ... */
    current_rewards: Coin[];
    /** total_delegation ... */
    total_delegation: string;
    /** latest_index_k ... */
    latest_index_k: string;
    /** delegator_count the amount of different addresses delegating to the staker */
    delegator_count: string;
    /** latest_index_was_undelegation helps indicates when an entry can be deleted */
    latest_index_was_undelegation: boolean;
}
/**
 * DelegationSlash represents an f1-slash
 * these entries needs to be iterated to obtain the current amount of the actual stake
 * Every staker can have n slash-entries
 */
export interface DelegationSlash {
    /** staker who got slashed */
    staker: string;
    /** k_index for f1-algorithm */
    k_index: string;
    /** fraction that got slashed */
    fraction: string;
}
/** UndelegationQueueEntry ... */
export interface UndelegationQueueEntry {
    /** index ... */
    index: string;
    /** staker ... */
    staker: string;
    /** delegator ... */
    delegator: string;
    /** amount ... */
    amount: string;
    /** creation_time ... */
    creation_time: string;
}
/** QueueState ... */
export interface QueueState {
    /** low_index ... */
    low_index: string;
    /** high_index ... */
    high_index: string;
}
/** RedelegationCooldown ... */
export interface RedelegationCooldown {
    /** low_index ... */
    address: string;
    /** high_index ... */
    creation_date: string;
}
export declare const Delegator: MessageFns<Delegator>;
export declare const DelegationEntry: MessageFns<DelegationEntry>;
export declare const DelegationData: MessageFns<DelegationData>;
export declare const DelegationSlash: MessageFns<DelegationSlash>;
export declare const UndelegationQueueEntry: MessageFns<UndelegationQueueEntry>;
export declare const QueueState: MessageFns<QueueState>;
export declare const RedelegationCooldown: MessageFns<RedelegationCooldown>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
