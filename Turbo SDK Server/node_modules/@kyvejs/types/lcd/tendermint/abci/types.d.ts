import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PublicKey } from "../crypto/keys";
import { ProofOps } from "../crypto/proof";
import { ConsensusParams } from "../types/params";
import { BlockIDFlag } from "../types/validator";
export declare const protobufPackage = "tendermint.abci";
export declare enum CheckTxType {
    NEW = "NEW",
    RECHECK = "RECHECK",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function checkTxTypeFromJSON(object: any): CheckTxType;
export declare function checkTxTypeToJSON(object: CheckTxType): string;
export declare function checkTxTypeToNumber(object: CheckTxType): number;
export declare enum MisbehaviorType {
    UNKNOWN = "UNKNOWN",
    DUPLICATE_VOTE = "DUPLICATE_VOTE",
    LIGHT_CLIENT_ATTACK = "LIGHT_CLIENT_ATTACK",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function misbehaviorTypeFromJSON(object: any): MisbehaviorType;
export declare function misbehaviorTypeToJSON(object: MisbehaviorType): string;
export declare function misbehaviorTypeToNumber(object: MisbehaviorType): number;
export interface Request {
    echo?: RequestEcho | undefined;
    flush?: RequestFlush | undefined;
    info?: RequestInfo | undefined;
    init_chain?: RequestInitChain | undefined;
    query?: RequestQuery | undefined;
    check_tx?: RequestCheckTx | undefined;
    commit?: RequestCommit | undefined;
    list_snapshots?: RequestListSnapshots | undefined;
    offer_snapshot?: RequestOfferSnapshot | undefined;
    load_snapshot_chunk?: RequestLoadSnapshotChunk | undefined;
    apply_snapshot_chunk?: RequestApplySnapshotChunk | undefined;
    prepare_proposal?: RequestPrepareProposal | undefined;
    process_proposal?: RequestProcessProposal | undefined;
    extend_vote?: RequestExtendVote | undefined;
    verify_vote_extension?: RequestVerifyVoteExtension | undefined;
    finalize_block?: RequestFinalizeBlock | undefined;
}
export interface RequestEcho {
    message: string;
}
export interface RequestFlush {
}
export interface RequestInfo {
    version: string;
    block_version: string;
    p2p_version: string;
    abci_version: string;
}
export interface RequestInitChain {
    time?: Date | undefined;
    chain_id: string;
    consensus_params?: ConsensusParams | undefined;
    validators: ValidatorUpdate[];
    app_state_bytes: Uint8Array;
    initial_height: string;
}
export interface RequestQuery {
    data: Uint8Array;
    path: string;
    height: string;
    prove: boolean;
}
export interface RequestCheckTx {
    tx: Uint8Array;
    type: CheckTxType;
}
export interface RequestCommit {
}
/** lists available snapshots */
export interface RequestListSnapshots {
}
/** offers a snapshot to the application */
export interface RequestOfferSnapshot {
    /** snapshot offered by peers */
    snapshot?: Snapshot | undefined;
    /** light client-verified app hash for snapshot height */
    app_hash: Uint8Array;
}
/** loads a snapshot chunk */
export interface RequestLoadSnapshotChunk {
    height: string;
    format: number;
    chunk: number;
}
/** Applies a snapshot chunk */
export interface RequestApplySnapshotChunk {
    index: number;
    chunk: Uint8Array;
    sender: string;
}
export interface RequestPrepareProposal {
    /** the modified transactions cannot exceed this size. */
    max_tx_bytes: string;
    /**
     * txs is an array of transactions that will be included in a block,
     * sent to the app for possible modifications.
     */
    txs: Uint8Array[];
    local_last_commit?: ExtendedCommitInfo | undefined;
    misbehavior: Misbehavior[];
    height: string;
    time?: Date | undefined;
    next_validators_hash: Uint8Array;
    /** address of the public key of the validator proposing the block. */
    proposer_address: Uint8Array;
}
export interface RequestProcessProposal {
    txs: Uint8Array[];
    proposed_last_commit?: CommitInfo | undefined;
    misbehavior: Misbehavior[];
    /** hash is the merkle root hash of the fields of the proposed block. */
    hash: Uint8Array;
    height: string;
    time?: Date | undefined;
    next_validators_hash: Uint8Array;
    /** address of the public key of the original proposer of the block. */
    proposer_address: Uint8Array;
}
/** Extends a vote with application-injected data */
export interface RequestExtendVote {
    /** the hash of the block that this vote may be referring to */
    hash: Uint8Array;
    /** the height of the extended vote */
    height: string;
    /** info of the block that this vote may be referring to */
    time?: Date | undefined;
    txs: Uint8Array[];
    proposed_last_commit?: CommitInfo | undefined;
    misbehavior: Misbehavior[];
    next_validators_hash: Uint8Array;
    /** address of the public key of the original proposer of the block. */
    proposer_address: Uint8Array;
}
/** Verify the vote extension */
export interface RequestVerifyVoteExtension {
    /** the hash of the block that this received vote corresponds to */
    hash: Uint8Array;
    /** the validator that signed the vote extension */
    validator_address: Uint8Array;
    height: string;
    vote_extension: Uint8Array;
}
export interface RequestFinalizeBlock {
    txs: Uint8Array[];
    decided_last_commit?: CommitInfo | undefined;
    misbehavior: Misbehavior[];
    /** hash is the merkle root hash of the fields of the decided block. */
    hash: Uint8Array;
    height: string;
    time?: Date | undefined;
    next_validators_hash: Uint8Array;
    /** proposer_address is the address of the public key of the original proposer of the block. */
    proposer_address: Uint8Array;
}
export interface Response {
    exception?: ResponseException | undefined;
    echo?: ResponseEcho | undefined;
    flush?: ResponseFlush | undefined;
    info?: ResponseInfo | undefined;
    init_chain?: ResponseInitChain | undefined;
    query?: ResponseQuery | undefined;
    check_tx?: ResponseCheckTx | undefined;
    commit?: ResponseCommit | undefined;
    list_snapshots?: ResponseListSnapshots | undefined;
    offer_snapshot?: ResponseOfferSnapshot | undefined;
    load_snapshot_chunk?: ResponseLoadSnapshotChunk | undefined;
    apply_snapshot_chunk?: ResponseApplySnapshotChunk | undefined;
    prepare_proposal?: ResponsePrepareProposal | undefined;
    process_proposal?: ResponseProcessProposal | undefined;
    extend_vote?: ResponseExtendVote | undefined;
    verify_vote_extension?: ResponseVerifyVoteExtension | undefined;
    finalize_block?: ResponseFinalizeBlock | undefined;
}
/** nondeterministic */
export interface ResponseException {
    error: string;
}
export interface ResponseEcho {
    message: string;
}
export interface ResponseFlush {
}
export interface ResponseInfo {
    data: string;
    version: string;
    app_version: string;
    last_block_height: string;
    last_block_app_hash: Uint8Array;
}
export interface ResponseInitChain {
    consensus_params?: ConsensusParams | undefined;
    validators: ValidatorUpdate[];
    app_hash: Uint8Array;
}
export interface ResponseQuery {
    code: number;
    /** bytes data = 2; // use "value" instead. */
    log: string;
    /** nondeterministic */
    info: string;
    index: string;
    key: Uint8Array;
    value: Uint8Array;
    proof_ops?: ProofOps | undefined;
    height: string;
    codespace: string;
}
export interface ResponseCheckTx {
    code: number;
    data: Uint8Array;
    /** nondeterministic */
    log: string;
    /** nondeterministic */
    info: string;
    gas_wanted: string;
    gas_used: string;
    events: Event[];
    codespace: string;
}
export interface ResponseCommit {
    retain_height: string;
}
export interface ResponseListSnapshots {
    snapshots: Snapshot[];
}
export interface ResponseOfferSnapshot {
    result: ResponseOfferSnapshot_Result;
}
export declare enum ResponseOfferSnapshot_Result {
    /** UNKNOWN - Unknown result, abort all snapshot restoration */
    UNKNOWN = "UNKNOWN",
    /** ACCEPT - Snapshot accepted, apply chunks */
    ACCEPT = "ACCEPT",
    /** ABORT - Abort all snapshot restoration */
    ABORT = "ABORT",
    /** REJECT - Reject this specific snapshot, try others */
    REJECT = "REJECT",
    /** REJECT_FORMAT - Reject all snapshots of this format, try others */
    REJECT_FORMAT = "REJECT_FORMAT",
    /** REJECT_SENDER - Reject all snapshots from the sender(s), try others */
    REJECT_SENDER = "REJECT_SENDER",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function responseOfferSnapshot_ResultFromJSON(object: any): ResponseOfferSnapshot_Result;
export declare function responseOfferSnapshot_ResultToJSON(object: ResponseOfferSnapshot_Result): string;
export declare function responseOfferSnapshot_ResultToNumber(object: ResponseOfferSnapshot_Result): number;
export interface ResponseLoadSnapshotChunk {
    chunk: Uint8Array;
}
export interface ResponseApplySnapshotChunk {
    result: ResponseApplySnapshotChunk_Result;
    /** Chunks to refetch and reapply */
    refetch_chunks: number[];
    /** Chunk senders to reject and ban */
    reject_senders: string[];
}
export declare enum ResponseApplySnapshotChunk_Result {
    /** UNKNOWN - Unknown result, abort all snapshot restoration */
    UNKNOWN = "UNKNOWN",
    /** ACCEPT - Chunk successfully accepted */
    ACCEPT = "ACCEPT",
    /** ABORT - Abort all snapshot restoration */
    ABORT = "ABORT",
    /** RETRY - Retry chunk (combine with refetch and reject) */
    RETRY = "RETRY",
    /** RETRY_SNAPSHOT - Retry snapshot (combine with refetch and reject) */
    RETRY_SNAPSHOT = "RETRY_SNAPSHOT",
    /** REJECT_SNAPSHOT - Reject this snapshot, try others */
    REJECT_SNAPSHOT = "REJECT_SNAPSHOT",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function responseApplySnapshotChunk_ResultFromJSON(object: any): ResponseApplySnapshotChunk_Result;
export declare function responseApplySnapshotChunk_ResultToJSON(object: ResponseApplySnapshotChunk_Result): string;
export declare function responseApplySnapshotChunk_ResultToNumber(object: ResponseApplySnapshotChunk_Result): number;
export interface ResponsePrepareProposal {
    txs: Uint8Array[];
}
export interface ResponseProcessProposal {
    status: ResponseProcessProposal_ProposalStatus;
}
export declare enum ResponseProcessProposal_ProposalStatus {
    UNKNOWN = "UNKNOWN",
    ACCEPT = "ACCEPT",
    REJECT = "REJECT",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function responseProcessProposal_ProposalStatusFromJSON(object: any): ResponseProcessProposal_ProposalStatus;
export declare function responseProcessProposal_ProposalStatusToJSON(object: ResponseProcessProposal_ProposalStatus): string;
export declare function responseProcessProposal_ProposalStatusToNumber(object: ResponseProcessProposal_ProposalStatus): number;
export interface ResponseExtendVote {
    vote_extension: Uint8Array;
}
export interface ResponseVerifyVoteExtension {
    status: ResponseVerifyVoteExtension_VerifyStatus;
}
export declare enum ResponseVerifyVoteExtension_VerifyStatus {
    UNKNOWN = "UNKNOWN",
    ACCEPT = "ACCEPT",
    /**
     * REJECT - Rejecting the vote extension will reject the entire precommit by the sender.
     * Incorrectly implementing this thus has liveness implications as it may affect
     * CometBFT's ability to receive 2/3+ valid votes to finalize the block.
     * Honest nodes should never be rejected.
     */
    REJECT = "REJECT",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function responseVerifyVoteExtension_VerifyStatusFromJSON(object: any): ResponseVerifyVoteExtension_VerifyStatus;
export declare function responseVerifyVoteExtension_VerifyStatusToJSON(object: ResponseVerifyVoteExtension_VerifyStatus): string;
export declare function responseVerifyVoteExtension_VerifyStatusToNumber(object: ResponseVerifyVoteExtension_VerifyStatus): number;
export interface ResponseFinalizeBlock {
    /** set of block events emmitted as part of executing the block */
    events: Event[];
    /**
     * the result of executing each transaction including the events
     * the particular transction emitted. This should match the order
     * of the transactions delivered in the block itself
     */
    tx_results: ExecTxResult[];
    /** a list of updates to the validator set. These will reflect the validator set at current height + 2. */
    validator_updates: ValidatorUpdate[];
    /** updates to the consensus params, if any. */
    consensus_param_updates?: ConsensusParams | undefined;
    /**
     * app_hash is the hash of the applications' state which is used to confirm that execution of the transactions was
     * deterministic. It is up to the application to decide which algorithm to use.
     */
    app_hash: Uint8Array;
}
export interface CommitInfo {
    round: number;
    votes: VoteInfo[];
}
/**
 * ExtendedCommitInfo is similar to CommitInfo except that it is only used in
 * the PrepareProposal request such that CometBFT can provide vote extensions
 * to the application.
 */
export interface ExtendedCommitInfo {
    /** The round at which the block proposer decided in the previous height. */
    round: number;
    /**
     * List of validators' addresses in the last validator set with their voting
     * information, including vote extensions.
     */
    votes: ExtendedVoteInfo[];
}
/**
 * Event allows application developers to attach additional information to
 * ResponseFinalizeBlock and ResponseCheckTx.
 * Later, transactions may be queried using these events.
 */
export interface Event {
    type: string;
    attributes: EventAttribute[];
}
/** EventAttribute is a single key-value pair, associated with an event. */
export interface EventAttribute {
    key: string;
    value: string;
    /** nondeterministic */
    index: boolean;
}
/**
 * ExecTxResult contains results of executing one individual transaction.
 *
 * * Its structure is equivalent to #ResponseDeliverTx which will be deprecated/deleted
 */
export interface ExecTxResult {
    code: number;
    data: Uint8Array;
    /** nondeterministic */
    log: string;
    /** nondeterministic */
    info: string;
    gas_wanted: string;
    gas_used: string;
    /** nondeterministic */
    events: Event[];
    codespace: string;
}
/**
 * TxResult contains results of executing the transaction.
 *
 * One usage is indexing transaction results.
 */
export interface TxResult {
    height: string;
    index: number;
    tx: Uint8Array;
    result?: ExecTxResult | undefined;
}
export interface Validator {
    /** The first 20 bytes of SHA256(public key) */
    address: Uint8Array;
    /** PubKey pub_key = 2 [(gogoproto.nullable)=false]; */
    power: string;
}
export interface ValidatorUpdate {
    pub_key?: PublicKey | undefined;
    power: string;
}
export interface VoteInfo {
    validator?: Validator | undefined;
    block_id_flag: BlockIDFlag;
}
export interface ExtendedVoteInfo {
    /** The validator that sent the vote. */
    validator?: Validator | undefined;
    /** Non-deterministic extension provided by the sending validator's application. */
    vote_extension: Uint8Array;
    /** Vote extension signature created by CometBFT */
    extension_signature: Uint8Array;
    /** block_id_flag indicates whether the validator voted for a block, nil, or did not vote at all */
    block_id_flag: BlockIDFlag;
}
export interface Misbehavior {
    type: MisbehaviorType;
    /** The offending validator */
    validator?: Validator | undefined;
    /** The height when the offense occurred */
    height: string;
    /** The corresponding time where the offense occurred */
    time?: Date | undefined;
    /**
     * Total voting power of the validator set in case the ABCI application does
     * not store historical validators.
     * https://github.com/tendermint/tendermint/issues/4581
     */
    total_voting_power: string;
}
export interface Snapshot {
    /** The height at which the snapshot was taken */
    height: string;
    /** The application-specific snapshot format */
    format: number;
    /** Number of chunks in the snapshot */
    chunks: number;
    /** Arbitrary snapshot hash, equal only if identical */
    hash: Uint8Array;
    /** Arbitrary application metadata */
    metadata: Uint8Array;
}
export declare const Request: MessageFns<Request>;
export declare const RequestEcho: MessageFns<RequestEcho>;
export declare const RequestFlush: MessageFns<RequestFlush>;
export declare const RequestInfo: MessageFns<RequestInfo>;
export declare const RequestInitChain: MessageFns<RequestInitChain>;
export declare const RequestQuery: MessageFns<RequestQuery>;
export declare const RequestCheckTx: MessageFns<RequestCheckTx>;
export declare const RequestCommit: MessageFns<RequestCommit>;
export declare const RequestListSnapshots: MessageFns<RequestListSnapshots>;
export declare const RequestOfferSnapshot: MessageFns<RequestOfferSnapshot>;
export declare const RequestLoadSnapshotChunk: MessageFns<RequestLoadSnapshotChunk>;
export declare const RequestApplySnapshotChunk: MessageFns<RequestApplySnapshotChunk>;
export declare const RequestPrepareProposal: MessageFns<RequestPrepareProposal>;
export declare const RequestProcessProposal: MessageFns<RequestProcessProposal>;
export declare const RequestExtendVote: MessageFns<RequestExtendVote>;
export declare const RequestVerifyVoteExtension: MessageFns<RequestVerifyVoteExtension>;
export declare const RequestFinalizeBlock: MessageFns<RequestFinalizeBlock>;
export declare const Response: MessageFns<Response>;
export declare const ResponseException: MessageFns<ResponseException>;
export declare const ResponseEcho: MessageFns<ResponseEcho>;
export declare const ResponseFlush: MessageFns<ResponseFlush>;
export declare const ResponseInfo: MessageFns<ResponseInfo>;
export declare const ResponseInitChain: MessageFns<ResponseInitChain>;
export declare const ResponseQuery: MessageFns<ResponseQuery>;
export declare const ResponseCheckTx: MessageFns<ResponseCheckTx>;
export declare const ResponseCommit: MessageFns<ResponseCommit>;
export declare const ResponseListSnapshots: MessageFns<ResponseListSnapshots>;
export declare const ResponseOfferSnapshot: MessageFns<ResponseOfferSnapshot>;
export declare const ResponseLoadSnapshotChunk: MessageFns<ResponseLoadSnapshotChunk>;
export declare const ResponseApplySnapshotChunk: MessageFns<ResponseApplySnapshotChunk>;
export declare const ResponsePrepareProposal: MessageFns<ResponsePrepareProposal>;
export declare const ResponseProcessProposal: MessageFns<ResponseProcessProposal>;
export declare const ResponseExtendVote: MessageFns<ResponseExtendVote>;
export declare const ResponseVerifyVoteExtension: MessageFns<ResponseVerifyVoteExtension>;
export declare const ResponseFinalizeBlock: MessageFns<ResponseFinalizeBlock>;
export declare const CommitInfo: MessageFns<CommitInfo>;
export declare const ExtendedCommitInfo: MessageFns<ExtendedCommitInfo>;
export declare const Event: MessageFns<Event>;
export declare const EventAttribute: MessageFns<EventAttribute>;
export declare const ExecTxResult: MessageFns<ExecTxResult>;
export declare const TxResult: MessageFns<TxResult>;
export declare const Validator: MessageFns<Validator>;
export declare const ValidatorUpdate: MessageFns<ValidatorUpdate>;
export declare const VoteInfo: MessageFns<VoteInfo>;
export declare const ExtendedVoteInfo: MessageFns<ExtendedVoteInfo>;
export declare const Misbehavior: MessageFns<Misbehavior>;
export declare const Snapshot: MessageFns<Snapshot>;
export interface ABCI {
    Echo(request: RequestEcho): Promise<ResponseEcho>;
    Flush(request: RequestFlush): Promise<ResponseFlush>;
    Info(request: RequestInfo): Promise<ResponseInfo>;
    CheckTx(request: RequestCheckTx): Promise<ResponseCheckTx>;
    Query(request: RequestQuery): Promise<ResponseQuery>;
    Commit(request: RequestCommit): Promise<ResponseCommit>;
    InitChain(request: RequestInitChain): Promise<ResponseInitChain>;
    ListSnapshots(request: RequestListSnapshots): Promise<ResponseListSnapshots>;
    OfferSnapshot(request: RequestOfferSnapshot): Promise<ResponseOfferSnapshot>;
    LoadSnapshotChunk(request: RequestLoadSnapshotChunk): Promise<ResponseLoadSnapshotChunk>;
    ApplySnapshotChunk(request: RequestApplySnapshotChunk): Promise<ResponseApplySnapshotChunk>;
    PrepareProposal(request: RequestPrepareProposal): Promise<ResponsePrepareProposal>;
    ProcessProposal(request: RequestProcessProposal): Promise<ResponseProcessProposal>;
    ExtendVote(request: RequestExtendVote): Promise<ResponseExtendVote>;
    VerifyVoteExtension(request: RequestVerifyVoteExtension): Promise<ResponseVerifyVoteExtension>;
    FinalizeBlock(request: RequestFinalizeBlock): Promise<ResponseFinalizeBlock>;
}
export declare const ABCIServiceName = "tendermint.abci.ABCI";
export declare class ABCIClientImpl implements ABCI {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    Echo(request: RequestEcho): Promise<ResponseEcho>;
    Flush(request: RequestFlush): Promise<ResponseFlush>;
    Info(request: RequestInfo): Promise<ResponseInfo>;
    CheckTx(request: RequestCheckTx): Promise<ResponseCheckTx>;
    Query(request: RequestQuery): Promise<ResponseQuery>;
    Commit(request: RequestCommit): Promise<ResponseCommit>;
    InitChain(request: RequestInitChain): Promise<ResponseInitChain>;
    ListSnapshots(request: RequestListSnapshots): Promise<ResponseListSnapshots>;
    OfferSnapshot(request: RequestOfferSnapshot): Promise<ResponseOfferSnapshot>;
    LoadSnapshotChunk(request: RequestLoadSnapshotChunk): Promise<ResponseLoadSnapshotChunk>;
    ApplySnapshotChunk(request: RequestApplySnapshotChunk): Promise<ResponseApplySnapshotChunk>;
    PrepareProposal(request: RequestPrepareProposal): Promise<ResponsePrepareProposal>;
    ProcessProposal(request: RequestProcessProposal): Promise<ResponseProcessProposal>;
    ExtendVote(request: RequestExtendVote): Promise<ResponseExtendVote>;
    VerifyVoteExtension(request: RequestVerifyVoteExtension): Promise<ResponseVerifyVoteExtension>;
    FinalizeBlock(request: RequestFinalizeBlock): Promise<ResponseFinalizeBlock>;
}
interface Rpc {
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
