import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Validator } from "../../../cosmos/staking/v1beta1/staking";
import { PoolStatus } from "../../pool/v1beta1/pool";
export declare const protobufPackage = "kyve.query.v1beta1";
/**
 * BasicPool contains the necessary properties need for a pool
 * to be displayed in the UI
 */
export interface BasicPool {
    /** id is the ID of the pool */
    id: string;
    /** name of the pool */
    name: string;
    /**
     * runtime for the protocol nodes
     * like evm, bitcoin, etc.
     */
    runtime: string;
    /** logo of the pool */
    logo: string;
    /** inflation_share_weight is the base payout for each bundle reward */
    inflation_share_weight: string;
    /** upload_interval is the interval bundles get created */
    upload_interval: string;
    /**
     * total_funds of the pool. If the pool runs
     * out of funds no more bundles will be produced
     */
    total_funds: Coin[];
    /** total_stake of the pool */
    total_stake: string;
    /**
     * status of the pool if pool is able
     * to produce bundles, etc.
     */
    status: PoolStatus;
}
/**
 * FullStaker aggregates information from the staker and its delegators
 * as well as pending queue entries into one object.
 * It contains almost all needed information for a convenient usage
 */
export interface FullStaker {
    /** address of the staker */
    address: string;
    validator?: Validator | undefined;
    /**
     * validator_delegators returns the amount of delegators which have delegated
     * into this validator
     */
    validator_delegators: string;
    /**
     * validator_self_delegation returns the amount in $KYVE the validator has
     * personally delegated
     */
    validator_self_delegation: string;
    /**
     * validator_unbonding returns the amount in $KYVE the validator is currently
     * unbonding from his validator
     */
    validator_unbonding: string;
    /**
     * validator_total_pool_stake returns the amount the validator has in total
     * staked in all his pools
     */
    validator_total_pool_stake: string;
    validator_commission_rewards: Coin[];
    /**
     * pools is a list of all pools the staker is currently
     * participating, i.e. allowed to vote and upload data.
     */
    pools: PoolMembership[];
}
/**
 * CommissionChangeEntry shows when the old commission
 * of a staker will change to the new commission
 */
export interface CommissionChangeEntry {
    /**
     * commission is the new commission that will
     * become active once the change-time is over
     */
    commission: string;
    /**
     * creation_date is the UNIX-timestamp (in seconds)
     * of when the entry was created.
     */
    creation_date: string;
}
/**
 * StakeFractionChangeEntry shows when the old stake fraction
 * of a staker will change to the new stake fraction
 */
export interface StakeFractionChangeEntry {
    /**
     * stake_fraction is the new stake_fraction that will
     * become active once the change-time is over
     */
    stake_fraction: string;
    /**
     * creation_date is the UNIX-timestamp (in seconds)
     * of when the entry was created.
     */
    creation_date: string;
}
/**
 * PoolMembership shows in which pool the staker
 * is participating
 */
export interface PoolMembership {
    /** pool contains useful information about the pool */
    pool?: BasicPool | undefined;
    /**
     * points indicates if the staker is inactive
     * If the staker misses a vote, a point is added.
     * After 5 points the staker is removed from
     * the stakers set.
     */
    points: string;
    /**
     * is_leaving indicates if a user has scheduled a
     * a PoolLeave entry. After the leave-time is over
     * the staker will no longer participate in that pool
     */
    is_leaving: boolean;
    /**
     * pool address is the address which is authorized to vote
     * and submit bundles. If the server gets compromised
     * the staker can just change the pool address .
     */
    pool_address: string;
    /**
     * balance is the pool address  account balance and indicates
     * whether or not the pool account needs additional funds to
     * pay for gas fees
     */
    balance: string;
    /**
     * commission is the commission the validator has chosen for
     * this specific pool
     */
    commission: string;
    /**
     * pending_commission_change shows if the staker plans
     * to change its commission. Delegators will see a warning in
     * the UI. A Commission change takes some time until
     * the commission is applied. Users have time to redelegate
     * if they not agree with the new commission.
     */
    pending_commission_change?: CommissionChangeEntry | undefined;
    /**
     * stake fraction is a percentage the validator has chosen for
     * this pool. It is the fraction of how much of his total stake
     * the validator wants to stake in this specific pool
     */
    stake_fraction: string;
    /**
     * pending_stake_fraction_change shows if the staker plans
     * to change its stake fraction. Delegators will see a warning in
     * the UI. A stake fraction change takes some time until
     * the stake fraction is applied. Users have time to redelegate
     * if they not agree with the new stake fraction.
     */
    pending_stake_fraction_change?: StakeFractionChangeEntry | undefined;
    /**
     * pool stake shows the actual amount the validator has staked
     * in this pool. It can be lower than the specified stake fraction
     * because of the max voting power limit
     */
    pool_stake: string;
}
export declare const BasicPool: MessageFns<BasicPool>;
export declare const FullStaker: MessageFns<FullStaker>;
export declare const CommissionChangeEntry: MessageFns<CommissionChangeEntry>;
export declare const StakeFractionChangeEntry: MessageFns<StakeFractionChangeEntry>;
export declare const PoolMembership: MessageFns<PoolMembership>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
